package cs361.battleships.models;

import com.fasterxml.jackson.annotation.JsonProperty;
import controllers.AttackGameAction;

import java.util.ArrayList;
import java.util.List;

public class Board {

	@JsonProperty private List<Ship> boardShips;
	@JsonProperty private List<Result> attacks;
	private int length;
	private int width;

	/*
	DO NOT change the signature of this method. It is used by the grading scripts.
	 */
	public Board() {
		boardShips = new ArrayList<>(3);
		attacks = new ArrayList<>(100);
		length = 10;
		width = 10;
	}

	public Board(int length,int width){
		this.length = length;
		this.width = width;
	}

	/*
	DO NOT change the signature of this method. It is used by the grading scripts.
	 */
	public boolean placeShip(Ship ship, int x, char y, boolean isVertical) {
		// TODO Implement


	if(isVertical) {
	    // When the placement is vertical, the column is fixed, so we need to check if the ship
        // span over the boundary of row number.
        if (x + ship.getLength() - 1 > width) {
            return false;
        } else {
            // In this loop, the ship would set itself with occupied square generated by the loop.
            for (int i = 0; i < ship.getLength(); i++) {
                ship.setOccupiedSquare(new Square(x + i, y));
            }
            // The new ship would be added to the board.
            boardShips.add(ship);
            return true;
        }
    }
	else{
	    //Implement the same kind of function for horizontal placement TODO
        }

		return false;
	}

	/*
	DO NOT change the signature of this method. It is used by the grading scripts.
	 */
	public Result attack(int x, char y) {

		//TODO Implement

		Result attack = new Result(x,y);
		AttackStatus status = null;
		Ship attackedShip = null;

		//Check if HIT
		//Loop the ships
		for(int i = 0;i<boardShips.size();i++){
			//Loop the occupied square of ships
			for(int j=0;j<boardShips.get(i).getOccupiedSquares().size();j++){
				if(boardShips.get(i).getOccupiedSquares().get(j).getRow() == x && boardShips.get(i).getOccupiedSquares().get(j).getColumn() == y){
					status = AttackStatus.HIT;
					//Set ship for the result at this point
					attackedShip = boardShips.get(i);
				}
			}
		}

		//Check if the attack already exist
		for (int i = 0;i<attacks.size();i++){
			if(attacks.get(i).getLocation().getColumn() == y && attacks.get(i).getLocation().getRow() == x){
				status = AttackStatus.INVALID;
			}
		}

		//Then Check for Sink
		if(status == AttackStatus.HIT){
			attackedShip.incNumHits();
			if(attackedShip.getNumHits() >= attackedShip.getLength()){
				status = AttackStatus.SUNK;
			}
		}


		//Then Check for surrender

		if(status == AttackStatus.SUNK){
			int sunkCount = 0;
			for(int i = 0; i<boardShips.size();i++){
				if(boardShips.get(i).getNumHits() >= boardShips.get(i).getLength()) {
					sunkCount++;
				}
			}
			if(sunkCount == boardShips.size()){
				status = AttackStatus.SURRENDER;
			}
		}

		//If not sink, not surrender, not hit, assume it is miss

		if(status == null){
			status = AttackStatus.MISS;
		}


		//Check if the attack is out of grid
		if(x > width || (int)(y-'A') >= length){
			status = AttackStatus.INVALID;
		}
		System.out.print(x + " " + y + ": " + status);
		System.out.print("\n");
		attack.setResult(status);
		attack.setShip(attackedShip);
		attacks.add(attack);
		return attack;

	}

	public List<Ship> getShips() {
		return boardShips;
	}

	public void setShips(List<Ship> ships) {
		this.boardShips = ships;
	}

	public List<Result> getAttacks() {
		return this.attacks;
	}

	public void setAttacks(List<Result> attacks) {
		this.attacks = attacks;
	}
}
